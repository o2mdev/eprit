% kv_d01read Read data from .d01/.exp SpecMan data files
%
%   data = kv_smtdmsread(filename,...)
%   [ax,data] = kv_smtdmsread(filename,...);
%   [ax,data,dsc] = kv_smtdmsread(filename,...);
%
%   Reads data and axis information from tdms file generated by
%   SpecMan4EPR

% KAZAN dataviewer with plugins By Boris Epel & Alexey Silakov
% MPI of Bioinorganic Chemistry, Muelheim an der Ruhr, 2003
% Free for non-commercial use. Use the program at your own risk. 
% The authors retains all rights. 
% Contact: epel@mpi-muelheim.mpg.de


function varargout=epr_loadsmtdms(filename, varargin)

exp = epr_LoadTDMS(filename);

% cycle for streams
Streams{1} = TDMS_StreamToArray(exp.streams.Re);
Streams{2} = TDMS_StreamToArray(exp.streams.Im);
spec = Streams{1} + 1i* Streams{2};
        
ax = SpecManTDMSpar(exp);

if ~isfield(ax, 'x') || size(ax.x, 1)~=size(spec, 1)
  ax.x = 1:size(Streams{1}, 1);
end
ax.type = 'data';
if isfield(exp.root,'freq1')
    ax.freq1 = kvgetvalue(dsc.general_freq1);
end

% assign output depending on number of output arguments
% requested
switch nargout
 case 1
   varargout = {spec};
 case 2
   varargout = {ax, spec};
 case 3
   copy_sections = {'params','exp_info','sample_info','devices'};
   for jj = 1:length(copy_sections)
     if ~isfield(exp, copy_sections{jj}) || isempty(exp.(copy_sections{jj}))
       disp(['WARNING: Field ',copy_sections{jj},' is not present'])
       continue; 
     end
     fld = fieldnames(exp.(copy_sections{jj}));
     for ii=1:length(fld)
       exp.root.([copy_sections{jj},'_',fld{ii}]) = exp.(copy_sections{jj}).(fld{ii});
     end
   end
   varargout = {ax, spec, exp.root};
end

function data = TDMS_StreamToArray(array)

max_dim = double([array.dim1, array.dim2, array.dim3, array.dim4]);

total_data = prod(max_dim);

data_size = length(array.data{1});

% Find if data are indded multiple copies of the same set
one_set = total_data / data_size; 
n_rep = fix(length(array.data) / one_set);

data = zeros(prod(max_dim)/one_set, one_set);
for ii=1:one_set
  data(:, ii) = array.data{ii};
end

if n_rep > 1
  for jj = 2:n_rep
    for ii=1:one_set
      data(:, ii) = data(:, ii) + array.data{ii+one_set*(jj-1)};
    end
    data(:, ii) = data(:, ii) / n_rep;
  end
end

data = reshape(data, max_dim);
